// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Configuration for a aws_sdk_sso service client.
///
///
/// Service configuration allows for customization of endpoints, region, credentials providers,
/// and retry configuration. Generally, it is constructed automatically for you from a shared
/// configuration loaded by the `aws-config` crate. For example:
///
/// ```ignore
/// // Load a shared config from the environment
/// let shared_config = aws_config::from_env().load().await;
/// // The client constructor automatically converts the shared config into the service config
/// let client = Client::new(&shared_config);
/// ```
///
/// The service config can also be constructed manually using its builder.
///
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct Config {
    // Both `config` and `cloneable` are the same config, but the cloneable one
    // is kept around so that it is possible to convert back into a builder. This can be
    // optimized in the future.
    pub(crate) config: ::aws_smithy_types::config_bag::FrozenLayer,
    cloneable: ::aws_smithy_types::config_bag::CloneableLayer,
    pub(crate) runtime_components: ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    pub(crate) runtime_plugins: ::std::vec::Vec<::aws_smithy_runtime_api::client::runtime_plugin::SharedRuntimePlugin>,
}
impl Config {
    /// Constructs a config builder.
    pub fn builder() -> Builder {
        Builder::default()
    }
    /// Converts this config back into a builder so that it can be tweaked.
    pub fn to_builder(&self) -> Builder {
        Builder {
            config: self.cloneable.clone(),
            runtime_components: self.runtime_components.clone(),
            runtime_plugins: self.runtime_plugins.clone(),
        }
    }
    /// Return the [`SharedHttpConnector`](::aws_smithy_runtime_api::client::connectors::SharedHttpConnector) to use when making requests, if any.
    pub fn http_connector(&self) -> Option<::aws_smithy_runtime_api::client::connectors::SharedHttpConnector> {
        self.runtime_components.http_connector()
    }
    /// Returns the endpoint resolver.
    pub fn endpoint_resolver(&self) -> ::aws_smithy_runtime_api::client::endpoint::SharedEndpointResolver {
        self.runtime_components.endpoint_resolver().expect("resolver defaulted if not set")
    }
    /// Return a reference to the retry configuration contained in this config, if any.
    pub fn retry_config(&self) -> ::std::option::Option<&::aws_smithy_types::retry::RetryConfig> {
        self.config.load::<::aws_smithy_types::retry::RetryConfig>()
    }

    /// Return a cloned shared async sleep implementation from this config, if any.
    pub fn sleep_impl(&self) -> ::std::option::Option<::aws_smithy_async::rt::sleep::SharedAsyncSleep> {
        self.runtime_components.sleep_impl()
    }

    /// Return a reference to the timeout configuration contained in this config, if any.
    pub fn timeout_config(&self) -> ::std::option::Option<&::aws_smithy_types::timeout::TimeoutConfig> {
        self.config.load::<::aws_smithy_types::timeout::TimeoutConfig>()
    }

    #[doc(hidden)]
    /// Returns a reference to the retry partition contained in this config, if any.
    ///
    /// WARNING: This method is unstable and may be removed at any time. Do not rely on this
    /// method for anything!
    pub fn retry_partition(&self) -> ::std::option::Option<&::aws_smithy_runtime::client::retries::RetryPartition> {
        self.config.load::<::aws_smithy_runtime::client::retries::RetryPartition>()
    }

    /// Returns interceptors currently registered by the user.
    pub fn interceptors(&self) -> impl Iterator<Item = ::aws_smithy_runtime_api::client::interceptors::SharedInterceptor> + '_ {
        self.runtime_components.interceptors()
    }
    /// Return time source used for this service.
    pub fn time_source(&self) -> ::std::option::Option<::aws_smithy_async::time::SharedTimeSource> {
        self.runtime_components.time_source()
    }
    /// Returns the name of the app that is using the client, if it was provided.
    ///
    /// This _optional_ name is used to identify the application in the user agent that
    /// gets sent along with requests.
    pub fn app_name(&self) -> ::std::option::Option<&::aws_types::app_name::AppName> {
        self.config.load::<::aws_types::app_name::AppName>()
    }
    /// Returns the invocation ID generator if one was given in config.
    ///
    /// The invocation ID generator generates ID values for the `amz-sdk-invocation-id` header. By default, this will be a random UUID. Overriding it may be useful in tests that examine the HTTP request and need to be deterministic.
    pub fn invocation_id_generator(&self) -> ::std::option::Option<::aws_runtime::invocation_id::SharedInvocationIdGenerator> {
        self.config.load::<::aws_runtime::invocation_id::SharedInvocationIdGenerator>().cloned()
    }
    /// Creates a new [service config](crate::Config) from a [shared `config`](::aws_types::sdk_config::SdkConfig).
    pub fn new(config: &::aws_types::sdk_config::SdkConfig) -> Self {
        Builder::from(config).build()
    }
    /// The signature version 4 service signing name to use in the credential scope when signing requests.
    ///
    /// The signing service may be overridden by the `Endpoint`, or by specifying a custom
    /// [`SigningService`](aws_types::SigningService) during operation construction
    pub fn signing_service(&self) -> &'static str {
        "awsssoportal"
    }
    /// Returns the AWS region, if it was provided.
    pub fn region(&self) -> ::std::option::Option<&::aws_types::region::Region> {
        self.config.load::<::aws_types::region::Region>()
    }
    /// Returns the credentials cache.
    pub fn credentials_cache(&self) -> ::std::option::Option<::aws_credential_types::cache::SharedCredentialsCache> {
        self.config.load::<::aws_credential_types::cache::SharedCredentialsCache>().cloned()
    }
}
/// Builder for creating a `Config`.
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct Builder {
    pub(crate) config: ::aws_smithy_types::config_bag::CloneableLayer,
    pub(crate) runtime_components: ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    pub(crate) runtime_plugins: ::std::vec::Vec<::aws_smithy_runtime_api::client::runtime_plugin::SharedRuntimePlugin>,
}
impl ::std::default::Default for Builder {
    fn default() -> Self {
        Self {
            config: ::std::default::Default::default(),
            runtime_components: ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("service config"),
            runtime_plugins: ::std::default::Default::default(),
        }
    }
}
impl Builder {
    /// Constructs a config builder.
    pub fn new() -> Self {
        Self::default()
    }
    /// Sets the HTTP connector to use when making requests.
    ///
    /// # Examples
    /// ```no_run
    /// # #[cfg(test)]
    /// # mod tests {
    /// # #[test]
    /// # fn example() {
    /// use std::time::Duration;
    /// use aws_smithy_client::{Client, hyper_ext};
    /// use aws_smithy_client::erase::DynConnector;
    /// use aws_smithy_client::http_connector::ConnectorSettings;
    /// use aws_sdk_sso::config::Config;
    ///
    /// let https_connector = hyper_rustls::HttpsConnectorBuilder::new()
    ///     .with_webpki_roots()
    ///     .https_only()
    ///     .enable_http1()
    ///     .enable_http2()
    ///     .build();
    /// let smithy_connector = hyper_ext::Adapter::builder()
    ///     // Optionally set things like timeouts as well
    ///     .connector_settings(
    ///         ConnectorSettings::builder()
    ///             .connect_timeout(Duration::from_secs(5))
    ///             .build()
    ///     )
    ///     .build(https_connector);
    /// # }
    /// # }
    /// ```
    pub fn http_connector(mut self, http_connector: impl Into<::aws_smithy_client::http_connector::HttpConnector>) -> Self {
        self.set_http_connector(::std::option::Option::Some(http_connector));
        self
    }

    /// Sets the HTTP connector to use when making requests.
    ///
    /// # Examples
    /// ```no_run
    /// # #[cfg(test)]
    /// # mod tests {
    /// # #[test]
    /// # fn example() {
    /// use std::time::Duration;
    /// use aws_smithy_client::hyper_ext;
    /// use aws_smithy_client::http_connector::ConnectorSettings;
    /// use aws_sdk_sso::config::{Builder, Config};
    ///
    /// fn override_http_connector(builder: &mut Builder) {
    ///     let https_connector = hyper_rustls::HttpsConnectorBuilder::new()
    ///         .with_webpki_roots()
    ///         .https_only()
    ///         .enable_http1()
    ///         .enable_http2()
    ///         .build();
    ///     let smithy_connector = hyper_ext::Adapter::builder()
    ///         // Optionally set things like timeouts as well
    ///         .connector_settings(
    ///             ConnectorSettings::builder()
    ///                 .connect_timeout(Duration::from_secs(5))
    ///                 .build()
    ///         )
    ///         .build(https_connector);
    ///     builder.set_http_connector(Some(smithy_connector));
    /// }
    ///
    /// let mut builder = aws_sdk_sso::Config::builder();
    /// override_http_connector(&mut builder);
    /// let config = builder.build();
    /// # }
    /// # }
    /// ```
    pub fn set_http_connector(&mut self, http_connector: Option<impl Into<::aws_smithy_client::http_connector::HttpConnector>>) -> &mut Self {
        http_connector.map(|c| self.config.store_put(c.into()));
        self
    }
    /// Sets the endpoint resolver to use when making requests.
    ///
    /// Note: setting an endpoint resolver will replace any endpoint URL that has been set.
    ///

    ///
    /// When unset, the client will used a generated endpoint resolver based on the endpoint resolution
    /// rules for `aws_sdk_sso`.
    ///
    /// # Examples
    /// ```no_run
    /// use aws_smithy_http::endpoint;
    /// use aws_sdk_sso::config::endpoint::{Params as EndpointParams, DefaultResolver};
    /// /// Endpoint resolver which adds a prefix to the generated endpoint
    /// #[derive(Debug)]
    /// struct PrefixResolver {
    ///     base_resolver: DefaultResolver,
    ///     prefix: String
    /// }
    /// impl endpoint::ResolveEndpoint<EndpointParams> for PrefixResolver {
    ///   fn resolve_endpoint(&self, params: &EndpointParams) -> endpoint::Result {
    ///        self.base_resolver
    ///              .resolve_endpoint(params)
    ///              .map(|ep|{
    ///                   let url = ep.url().to_string();
    ///                   ep.into_builder().url(format!("{}.{}", &self.prefix, url)).build()
    ///               })
    ///   }
    /// }
    /// let prefix_resolver = PrefixResolver {
    ///     base_resolver: DefaultResolver::new(),
    ///     prefix: "subdomain".to_string()
    /// };
    /// let config = aws_sdk_sso::Config::builder().endpoint_resolver(prefix_resolver);
    /// ```

    pub fn endpoint_resolver(
        mut self,
        endpoint_resolver: impl ::aws_smithy_http::endpoint::ResolveEndpoint<crate::config::endpoint::Params> + 'static,
    ) -> Self {
        self.set_endpoint_resolver(::std::option::Option::Some(::aws_smithy_http::endpoint::SharedEndpointResolver::new(
            endpoint_resolver,
        )));
        self
    }

    /// Sets the endpoint resolver to use when making requests.
    ///
    /// When unset, the client will used a generated endpoint resolver based on the endpoint resolution
    /// rules for `aws_sdk_sso`.
    pub fn set_endpoint_resolver(
        &mut self,
        endpoint_resolver: ::std::option::Option<::aws_smithy_http::endpoint::SharedEndpointResolver<crate::config::endpoint::Params>>,
    ) -> &mut Self {
        self.config.store_or_unset(endpoint_resolver);
        self
    }
    /// Set the retry_config for the builder
    ///
    /// # Examples
    /// ```no_run
    /// use aws_sdk_sso::config::Config;
    /// use aws_sdk_sso::config::retry::RetryConfig;
    ///
    /// let retry_config = RetryConfig::standard().with_max_attempts(5);
    /// let config = Config::builder().retry_config(retry_config).build();
    /// ```
    pub fn retry_config(mut self, retry_config: ::aws_smithy_types::retry::RetryConfig) -> Self {
        self.set_retry_config(Some(retry_config));
        self
    }

    /// Set the retry_config for the builder
    ///
    /// # Examples
    /// ```no_run
    /// use aws_sdk_sso::config::{Builder, Config};
    /// use aws_sdk_sso::config::retry::RetryConfig;
    ///
    /// fn disable_retries(builder: &mut Builder) {
    ///     let retry_config = RetryConfig::standard().with_max_attempts(1);
    ///     builder.set_retry_config(Some(retry_config));
    /// }
    ///
    /// let mut builder = Config::builder();
    /// disable_retries(&mut builder);
    /// let config = builder.build();
    /// ```
    pub fn set_retry_config(&mut self, retry_config: ::std::option::Option<::aws_smithy_types::retry::RetryConfig>) -> &mut Self {
        retry_config.map(|r| self.config.store_put(r));
        self
    }
    /// Set the sleep_impl for the builder
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use aws_sdk_sso::config::{AsyncSleep, Config, SharedAsyncSleep, Sleep};
    ///
    /// #[derive(Debug)]
    /// pub struct ForeverSleep;
    ///
    /// impl AsyncSleep for ForeverSleep {
    ///     fn sleep(&self, duration: std::time::Duration) -> Sleep {
    ///         Sleep::new(std::future::pending())
    ///     }
    /// }
    ///
    /// let sleep_impl = SharedAsyncSleep::new(ForeverSleep);
    /// let config = Config::builder().sleep_impl(sleep_impl).build();
    /// ```
    pub fn sleep_impl(mut self, sleep_impl: ::aws_smithy_async::rt::sleep::SharedAsyncSleep) -> Self {
        self.set_sleep_impl(Some(sleep_impl));
        self
    }

    /// Set the sleep_impl for the builder
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use aws_sdk_sso::config::{AsyncSleep, Builder, Config, SharedAsyncSleep, Sleep};
    ///
    /// #[derive(Debug)]
    /// pub struct ForeverSleep;
    ///
    /// impl AsyncSleep for ForeverSleep {
    ///     fn sleep(&self, duration: std::time::Duration) -> Sleep {
    ///         Sleep::new(std::future::pending())
    ///     }
    /// }
    ///
    /// fn set_never_ending_sleep_impl(builder: &mut Builder) {
    ///     let sleep_impl = SharedAsyncSleep::new(ForeverSleep);
    ///     builder.set_sleep_impl(Some(sleep_impl));
    /// }
    ///
    /// let mut builder = Config::builder();
    /// set_never_ending_sleep_impl(&mut builder);
    /// let config = builder.build();
    /// ```
    pub fn set_sleep_impl(&mut self, sleep_impl: ::std::option::Option<::aws_smithy_async::rt::sleep::SharedAsyncSleep>) -> &mut Self {
        self.runtime_components.set_sleep_impl(sleep_impl);
        self
    }
    /// Set the timeout_config for the builder
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use std::time::Duration;
    /// use aws_sdk_sso::config::Config;
    /// use aws_sdk_sso::config::timeout::TimeoutConfig;
    ///
    /// let timeout_config = TimeoutConfig::builder()
    ///     .operation_attempt_timeout(Duration::from_secs(1))
    ///     .build();
    /// let config = Config::builder().timeout_config(timeout_config).build();
    /// ```
    pub fn timeout_config(mut self, timeout_config: ::aws_smithy_types::timeout::TimeoutConfig) -> Self {
        self.set_timeout_config(Some(timeout_config));
        self
    }

    /// Set the timeout_config for the builder
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use std::time::Duration;
    /// use aws_sdk_sso::config::{Builder, Config};
    /// use aws_sdk_sso::config::timeout::TimeoutConfig;
    ///
    /// fn set_request_timeout(builder: &mut Builder) {
    ///     let timeout_config = TimeoutConfig::builder()
    ///         .operation_attempt_timeout(Duration::from_secs(1))
    ///         .build();
    ///     builder.set_timeout_config(Some(timeout_config));
    /// }
    ///
    /// let mut builder = Config::builder();
    /// set_request_timeout(&mut builder);
    /// let config = builder.build();
    /// ```
    pub fn set_timeout_config(&mut self, timeout_config: ::std::option::Option<::aws_smithy_types::timeout::TimeoutConfig>) -> &mut Self {
        timeout_config.map(|t| self.config.store_put(t));
        self
    }
    #[doc(hidden)]
    /// Set the partition for retry-related state. When clients share a retry partition, they will
    /// also share things like token buckets and client rate limiters. By default, all clients
    /// for the same service will share a partition.
    pub fn retry_partition(mut self, retry_partition: ::aws_smithy_runtime::client::retries::RetryPartition) -> Self {
        self.set_retry_partition(Some(retry_partition));
        self
    }
    #[doc(hidden)]
    /// Set the partition for retry-related state. When clients share a retry partition, they will
    /// also share things like token buckets and client rate limiters. By default, all clients
    /// for the same service will share a partition.
    pub fn set_retry_partition(
        &mut self,
        retry_partition: ::std::option::Option<::aws_smithy_runtime::client::retries::RetryPartition>,
    ) -> &mut Self {
        retry_partition.map(|r| self.config.store_put(r));
        self
    }

    /// Add an [`Interceptor`](::aws_smithy_runtime_api::client::interceptors::Interceptor) that runs at specific stages of the request execution pipeline.
    ///
    /// Interceptors targeted at a certain stage are executed according to the pre-defined priority.
    /// The SDK provides a default set of interceptors. An interceptor configured by this method
    /// will run after those default interceptors.
    ///
    /// # Examples
    /// ```no_run
    /// # #[cfg(test)]
    /// # mod tests {
    /// # #[test]
    /// # fn example() {
    /// use aws_smithy_runtime_api::client::interceptors::context::phase::BeforeTransmit;
    /// use aws_smithy_runtime_api::client::interceptors::{Interceptor, InterceptorContext};
    /// use aws_smithy_types::config_bag::ConfigBag;
    /// use aws_sdk_sso::config::Config;
    ///
    /// fn base_url() -> String {
    ///     // ...
    ///     # String::new()
    /// }
    ///
    /// #[derive(Debug)]
    /// pub struct UriModifierInterceptor;
    /// impl Interceptor for UriModifierInterceptor {
    ///     fn modify_before_signing(
    ///         &self,
    ///         context: &mut InterceptorContext<BeforeTransmit>,
    ///         _cfg: &mut ConfigBag,
    ///     ) -> Result<(), aws_smithy_runtime_api::client::interceptors::BoxError> {
    ///         let request = context.request_mut();
    ///         let uri = format!("{}{}", base_url(), request.uri().path());
    ///         *request.uri_mut() = uri.parse()?;
    ///
    ///         Ok(())
    ///     }
    /// }
    ///
    /// let config = Config::builder()
    ///     .interceptor(UriModifierInterceptor)
    ///     .build();
    /// # }
    /// # }
    /// ```
    pub fn interceptor(mut self, interceptor: impl ::aws_smithy_runtime_api::client::interceptors::Interceptor + 'static) -> Self {
        self.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(interceptor));
        self
    }

    /// Add a [`SharedInterceptor`](::aws_smithy_runtime_api::client::interceptors::SharedInterceptor) that runs at specific stages of the request execution pipeline.
    ///
    /// Interceptors targeted at a certain stage are executed according to the pre-defined priority.
    /// The SDK provides a default set of interceptors. An interceptor configured by this method
    /// will run after those default interceptors.
    ///
    /// # Examples
    /// ```no_run
    /// # #[cfg(test)]
    /// # mod tests {
    /// # #[test]
    /// # fn example() {
    /// use aws_smithy_runtime_api::client::interceptors::context::phase::BeforeTransmit;
    /// use aws_smithy_runtime_api::client::interceptors::{Interceptor, InterceptorContext, SharedInterceptor};
    /// use aws_smithy_types::config_bag::ConfigBag;
    /// use aws_sdk_sso::config::{Builder, Config};
    ///
    /// fn base_url() -> String {
    ///     // ...
    ///     # String::new()
    /// }
    ///
    /// fn modify_request_uri(builder: &mut Builder) {
    ///     #[derive(Debug)]
    ///     pub struct UriModifierInterceptor;
    ///     impl Interceptor for UriModifierInterceptor {
    ///         fn modify_before_signing(
    ///             &self,
    ///             context: &mut InterceptorContext<BeforeTransmit>,
    ///             _cfg: &mut ConfigBag,
    ///         ) -> Result<(), aws_smithy_runtime_api::client::interceptors::BoxError> {
    ///             let request = context.request_mut();
    ///             let uri = format!("{}{}", base_url(), request.uri().path());
    ///             *request.uri_mut() = uri.parse()?;
    ///
    ///             Ok(())
    ///         }
    ///     }
    ///     builder.push_interceptor(SharedInterceptor::new(UriModifierInterceptor));
    /// }
    ///
    /// let mut builder = Config::builder();
    /// modify_request_uri(&mut builder);
    /// let config = builder.build();
    /// # }
    /// # }
    /// ```
    pub fn push_interceptor(&mut self, interceptor: ::aws_smithy_runtime_api::client::interceptors::SharedInterceptor) -> &mut Self {
        self.runtime_components.push_interceptor(interceptor);
        self
    }

    /// Set [`SharedInterceptor`](::aws_smithy_runtime_api::client::interceptors::SharedInterceptor)s for the builder.
    pub fn set_interceptors(
        &mut self,
        interceptors: impl IntoIterator<Item = ::aws_smithy_runtime_api::client::interceptors::SharedInterceptor>,
    ) -> &mut Self {
        self.runtime_components.set_interceptors(interceptors.into_iter());
        self
    }
    /// Sets the time source used for this service
    pub fn time_source(mut self, time_source: impl ::std::convert::Into<::aws_smithy_async::time::SharedTimeSource>) -> Self {
        self.set_time_source(::std::option::Option::Some(time_source.into()));
        self
    }
    /// Sets the time source used for this service
    pub fn set_time_source(&mut self, time_source: ::std::option::Option<::aws_smithy_async::time::SharedTimeSource>) -> &mut Self {
        self.runtime_components.set_time_source(time_source);
        self
    }
    /// Sets the name of the app that is using the client.
    ///
    /// This _optional_ name is used to identify the application in the user agent that
    /// gets sent along with requests.
    pub fn app_name(mut self, app_name: ::aws_types::app_name::AppName) -> Self {
        self.set_app_name(Some(app_name));
        self
    }
    /// Sets the name of the app that is using the client.
    ///
    /// This _optional_ name is used to identify the application in the user agent that
    /// gets sent along with requests.
    pub fn set_app_name(&mut self, app_name: ::std::option::Option<::aws_types::app_name::AppName>) -> &mut Self {
        self.config.store_or_unset(app_name);
        self
    }
    /// Overrides the default invocation ID generator.
    ///
    /// The invocation ID generator generates ID values for the `amz-sdk-invocation-id` header. By default, this will be a random UUID. Overriding it may be useful in tests that examine the HTTP request and need to be deterministic.
    pub fn invocation_id_generator(mut self, gen: impl ::aws_runtime::invocation_id::InvocationIdGenerator + 'static) -> Self {
        self.set_invocation_id_generator(::std::option::Option::Some(
            ::aws_runtime::invocation_id::SharedInvocationIdGenerator::new(gen),
        ));
        self
    }
    /// Overrides the default invocation ID generator.
    ///
    /// The invocation ID generator generates ID values for the `amz-sdk-invocation-id` header. By default, this will be a random UUID. Overriding it may be useful in tests that examine the HTTP request and need to be deterministic.
    pub fn set_invocation_id_generator(
        &mut self,
        gen: ::std::option::Option<::aws_runtime::invocation_id::SharedInvocationIdGenerator>,
    ) -> &mut Self {
        self.config.store_or_unset(gen);
        self
    }
    /// Sets the endpoint URL used to communicate with this service

    /// Note: this is used in combination with other endpoint rules, e.g. an API that applies a host-label prefix
    /// will be prefixed onto this URL. To fully override the endpoint resolver, use
    /// [`Builder::endpoint_resolver`].
    pub fn endpoint_url(mut self, endpoint_url: impl Into<::std::string::String>) -> Self {
        self.set_endpoint_url(Some(endpoint_url.into()));
        self
    }
    /// Sets the endpoint URL used to communicate with this service

    /// Note: this is used in combination with other endpoint rules, e.g. an API that applies a host-label prefix
    /// will be prefixed onto this URL. To fully override the endpoint resolver, use
    /// [`Builder::endpoint_resolver`].
    pub fn set_endpoint_url(&mut self, endpoint_url: Option<::std::string::String>) -> &mut Self {
        self.config.store_or_unset(endpoint_url.map(::aws_types::endpoint_config::EndpointUrl));
        self
    }
    /// When true, use the dual-stack endpoint. If the configured endpoint does not support dual-stack, dispatching the request MAY return an error.
    pub fn use_dual_stack(mut self, use_dual_stack: impl Into<bool>) -> Self {
        self.set_use_dual_stack(Some(use_dual_stack.into()));
        self
    }
    /// When true, use the dual-stack endpoint. If the configured endpoint does not support dual-stack, dispatching the request MAY return an error.
    pub fn set_use_dual_stack(&mut self, use_dual_stack: Option<bool>) -> &mut Self {
        self.config.store_or_unset(use_dual_stack.map(::aws_types::endpoint_config::UseDualStack));
        self
    }
    /// When true, send this request to the FIPS-compliant regional endpoint. If the configured endpoint does not have a FIPS compliant endpoint, dispatching the request will return an error.
    pub fn use_fips(mut self, use_fips: impl Into<bool>) -> Self {
        self.set_use_fips(Some(use_fips.into()));
        self
    }
    /// When true, send this request to the FIPS-compliant regional endpoint. If the configured endpoint does not have a FIPS compliant endpoint, dispatching the request will return an error.
    pub fn set_use_fips(&mut self, use_fips: Option<bool>) -> &mut Self {
        self.config.store_or_unset(use_fips.map(::aws_types::endpoint_config::UseFips));
        self
    }
    /// Sets the AWS region to use when making requests.
    ///
    /// # Examples
    /// ```no_run
    /// use aws_types::region::Region;
    /// use aws_sdk_sso::config::{Builder, Config};
    ///
    /// let config = aws_sdk_sso::Config::builder()
    ///     .region(Region::new("us-east-1"))
    ///     .build();
    /// ```
    pub fn region(mut self, region: impl ::std::convert::Into<::std::option::Option<::aws_types::region::Region>>) -> Self {
        self.set_region(region.into());
        self
    }
    /// Sets the AWS region to use when making requests.
    pub fn set_region(&mut self, region: ::std::option::Option<::aws_types::region::Region>) -> &mut Self {
        self.config.store_or_unset(region);
        self
    }
    /// Sets the credentials provider for this service
    pub fn credentials_provider(mut self, credentials_provider: impl ::aws_credential_types::provider::ProvideCredentials + 'static) -> Self {
        self.set_credentials_provider(::std::option::Option::Some(
            ::aws_credential_types::provider::SharedCredentialsProvider::new(credentials_provider),
        ));
        self
    }
    /// Sets the credentials provider for this service
    pub fn set_credentials_provider(
        &mut self,
        credentials_provider: ::std::option::Option<::aws_credential_types::provider::SharedCredentialsProvider>,
    ) -> &mut Self {
        self.config.store_or_unset(credentials_provider);
        self
    }
    /// Sets the credentials cache for this service
    pub fn credentials_cache(mut self, credentials_cache: ::aws_credential_types::cache::CredentialsCache) -> Self {
        self.set_credentials_cache(::std::option::Option::Some(credentials_cache));
        self
    }
    /// Sets the credentials cache for this service
    pub fn set_credentials_cache(&mut self, credentials_cache: ::std::option::Option<::aws_credential_types::cache::CredentialsCache>) -> &mut Self {
        self.config.store_or_unset(credentials_cache);
        self
    }
    /// Adds a runtime plugin to the config.
    #[allow(unused)]
    pub(crate) fn runtime_plugin(mut self, plugin: impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin + 'static) -> Self {
        self.push_runtime_plugin(::aws_smithy_runtime_api::client::runtime_plugin::SharedRuntimePlugin::new(plugin));
        self
    }
    /// Adds a runtime plugin to the config.
    #[allow(unused)]
    pub(crate) fn push_runtime_plugin(&mut self, plugin: ::aws_smithy_runtime_api::client::runtime_plugin::SharedRuntimePlugin) -> &mut Self {
        self.runtime_plugins.push(plugin);
        self
    }
    #[cfg(any(feature = "test-util", test))]
    #[allow(unused_mut)]
    /// Apply test defaults to the builder
    pub fn set_test_defaults(&mut self) -> &mut Self {
        self.set_time_source(::std::option::Option::Some(::aws_smithy_async::time::SharedTimeSource::new(
            ::aws_smithy_async::time::StaticTimeSource::new(::std::time::UNIX_EPOCH + ::std::time::Duration::from_secs(1234567890)),
        )));
        self.set_credentials_provider(Some(::aws_credential_types::provider::SharedCredentialsProvider::new(
            ::aws_credential_types::Credentials::for_tests(),
        )));
        self
    }
    #[cfg(any(feature = "test-util", test))]
    #[allow(unused_mut)]
    /// Apply test defaults to the builder
    pub fn with_test_defaults(mut self) -> Self {
        self.set_test_defaults();
        self
    }
    /// Builds a [`Config`].
    #[allow(unused_mut)]
    pub fn build(mut self) -> Config {
        let mut layer = self.config;
        let mut resolver = ::aws_smithy_runtime::client::config_override::Resolver::initial(&mut layer, &mut self.runtime_components);
        crate::config::set_connector(&mut resolver);
        crate::config::set_endpoint_resolver(&mut resolver);
        if layer.load::<::aws_smithy_types::retry::RetryConfig>().is_none() {
            layer.store_put(::aws_smithy_types::retry::RetryConfig::disabled());
        }
        let retry_config = layer
            .load::<::aws_smithy_types::retry::RetryConfig>()
            .expect("set to default above")
            .clone();

        if layer.load::<::aws_smithy_runtime::client::retries::RetryPartition>().is_none() {
            layer.store_put(::aws_smithy_runtime::client::retries::RetryPartition::new("sso"));
        }
        let retry_partition = layer
            .load::<::aws_smithy_runtime::client::retries::RetryPartition>()
            .expect("set to default above")
            .clone();

        if retry_config.has_retry() {
            ::tracing::debug!("using retry strategy with partition '{}'", retry_partition);
        }

        if retry_config.mode() == ::aws_smithy_types::retry::RetryMode::Adaptive {
            if let ::std::option::Option::Some(time_source) = self.runtime_components.time_source() {
                let seconds_since_unix_epoch = time_source
                    .now()
                    .duration_since(::std::time::SystemTime::UNIX_EPOCH)
                    .expect("the present takes place after the UNIX_EPOCH")
                    .as_secs_f64();
                let client_rate_limiter_partition = ::aws_smithy_runtime::client::retries::ClientRateLimiterPartition::new(retry_partition.clone());
                let client_rate_limiter = CLIENT_RATE_LIMITER.get_or_init(client_rate_limiter_partition, || {
                    ::aws_smithy_runtime::client::retries::ClientRateLimiter::new(seconds_since_unix_epoch)
                });
                layer.store_put(client_rate_limiter);
            }
        }

        // The token bucket is used for both standard AND adaptive retries.
        let token_bucket_partition = ::aws_smithy_runtime::client::retries::TokenBucketPartition::new(retry_partition);
        let token_bucket = TOKEN_BUCKET.get_or_init(token_bucket_partition, ::aws_smithy_runtime::client::retries::TokenBucket::default);
        layer.store_put(token_bucket);

        // TODO(enableNewSmithyRuntimeCleanup): Should not need to provide a default once smithy-rs#2770
        //  is resolved
        if layer.load::<::aws_smithy_types::timeout::TimeoutConfig>().is_none() {
            layer.store_put(::aws_smithy_types::timeout::TimeoutConfig::disabled());
        }

        self.runtime_components.set_retry_strategy(::std::option::Option::Some(
            ::aws_smithy_runtime_api::client::retries::SharedRetryStrategy::new(
                ::aws_smithy_runtime::client::retries::strategy::StandardRetryStrategy::new(&retry_config),
            ),
        ));
        if self.runtime_components.time_source().is_none() {
            self.runtime_components
                .set_time_source(::std::option::Option::Some(::std::default::Default::default()));
        }
        layer.store_put(crate::meta::API_METADATA.clone());
        layer.store_put(::aws_types::SigningService::from_static("awsssoportal"));
        layer
            .load::<::aws_types::region::Region>()
            .cloned()
            .map(|r| layer.store_put(::aws_types::region::SigningRegion::from(r)));
        if let Some(credentials_provider) = layer.load::<::aws_credential_types::provider::SharedCredentialsProvider>().cloned() {
            let cache_config = layer.load::<::aws_credential_types::cache::CredentialsCache>().cloned().unwrap_or_else({
                let sleep = self.runtime_components.sleep_impl();
                || match sleep {
                    Some(sleep) => ::aws_credential_types::cache::CredentialsCache::lazy_builder()
                        .sleep(sleep)
                        .into_credentials_cache(),
                    None => ::aws_credential_types::cache::CredentialsCache::lazy(),
                }
            });
            let shared_credentials_cache = cache_config.create_cache(credentials_provider);
            layer.store_put(shared_credentials_cache);
        }
        Config {
            config: ::aws_smithy_types::config_bag::Layer::from(layer.clone())
                .with_name("aws_sdk_sso::config::Config")
                .freeze(),
            cloneable: layer,
            runtime_components: self.runtime_components,
            runtime_plugins: self.runtime_plugins,
        }
    }
}
#[derive(::std::fmt::Debug)]
pub(crate) struct ServiceRuntimePlugin {
    config: ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer>,
    runtime_components: ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
}

impl ServiceRuntimePlugin {
    pub fn new(_service_config: crate::config::Config) -> Self {
        let config = { None };
        let mut runtime_components = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("ServiceRuntimePlugin");
        runtime_components.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(
            ::aws_smithy_runtime::client::connectors::connection_poisoning::ConnectionPoisoningInterceptor::new(),
        ) as _);
        runtime_components.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(
            ::aws_runtime::service_clock_skew::ServiceClockSkewInterceptor::new(),
        ) as _);
        runtime_components.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(
            ::aws_runtime::request_info::RequestInfoInterceptor::new(),
        ) as _);
        runtime_components.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(
            ::aws_runtime::user_agent::UserAgentInterceptor::new(),
        ) as _);
        runtime_components.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(
            ::aws_runtime::invocation_id::InvocationIdInterceptor::new(),
        ) as _);
        runtime_components.push_interceptor(::aws_smithy_runtime_api::client::interceptors::SharedInterceptor::new(
            ::aws_runtime::recursion_detection::RecursionDetectionInterceptor::new(),
        ) as _);
        runtime_components.push_auth_scheme(::aws_smithy_runtime_api::client::auth::SharedAuthScheme::new(
            ::aws_runtime::auth::sigv4::SigV4AuthScheme::new(),
        ));
        if let Some(credentials_cache) = _service_config.credentials_cache() {
            runtime_components.push_identity_resolver(
                ::aws_runtime::auth::sigv4::SCHEME_ID,
                ::aws_smithy_runtime_api::client::identity::SharedIdentityResolver::new(
                    ::aws_runtime::identity::credentials::CredentialsIdentityResolver::new(credentials_cache),
                ),
            );
        }
        Self { config, runtime_components }
    }
}

impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for ServiceRuntimePlugin {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        self.config.clone()
    }

    fn runtime_components(&self) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        ::std::borrow::Cow::Borrowed(&self.runtime_components)
    }
}

/// Cross-operation shared-state singletons
static TOKEN_BUCKET: ::aws_smithy_runtime::static_partition_map::StaticPartitionMap<
    ::aws_smithy_runtime::client::retries::TokenBucketPartition,
    ::aws_smithy_runtime::client::retries::TokenBucket,
> = ::aws_smithy_runtime::static_partition_map::StaticPartitionMap::new();
static CLIENT_RATE_LIMITER: ::aws_smithy_runtime::static_partition_map::StaticPartitionMap<
    ::aws_smithy_runtime::client::retries::ClientRateLimiterPartition,
    ::aws_smithy_runtime::client::retries::ClientRateLimiter,
> = ::aws_smithy_runtime::static_partition_map::StaticPartitionMap::new();
/// A plugin that enables configuration for a single operation invocation
///
/// The `config` method will return a `FrozenLayer` by storing values from `config_override`.
/// In the case of default values requested, they will be obtained from `client_config`.
#[derive(Debug)]
pub(crate) struct ConfigOverrideRuntimePlugin {
    pub(crate) config: ::aws_smithy_types::config_bag::FrozenLayer,
    pub(crate) components: ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
}

impl ConfigOverrideRuntimePlugin {
    pub(crate) fn new(
        config_override: Builder,
        initial_config: ::aws_smithy_types::config_bag::FrozenLayer,
        initial_components: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> Self {
        let mut layer = config_override.config;
        let mut components = config_override.runtime_components;
        let mut resolver =
            ::aws_smithy_runtime::client::config_override::Resolver::overrid(initial_config, initial_components, &mut layer, &mut components);

        crate::config::set_connector(&mut resolver);
        crate::config::set_endpoint_resolver(&mut resolver);
        match (
            resolver.config_mut().load::<::aws_credential_types::cache::CredentialsCache>().cloned(),
            resolver
                .config_mut()
                .load::<::aws_credential_types::provider::SharedCredentialsProvider>()
                .cloned(),
        ) {
            (::std::option::Option::None, ::std::option::Option::None) => {}
            (::std::option::Option::None, _) => {
                panic!("also specify `.credentials_cache` when overriding credentials provider for the operation");
            }
            (_, ::std::option::Option::None) => {
                panic!("also specify `.credentials_provider` when overriding credentials cache for the operation");
            }
            (::std::option::Option::Some(credentials_cache), ::std::option::Option::Some(credentials_provider)) => {
                resolver.config_mut().store_put(credentials_cache.create_cache(credentials_provider));
            }
        }

        let _ = resolver;
        Self {
            config: ::aws_smithy_types::config_bag::Layer::from(layer)
                .with_name("aws_sdk_sso::config::ConfigOverrideRuntimePlugin")
                .freeze(),
            components,
        }
    }
}

impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for ConfigOverrideRuntimePlugin {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        Some(self.config.clone())
    }

    fn runtime_components(&self) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        ::std::borrow::Cow::Borrowed(&self.components)
    }
}

pub use ::aws_smithy_runtime_api::client::interceptors::Interceptor;
pub use ::aws_smithy_runtime_api::client::interceptors::SharedInterceptor;
pub use ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponents;
pub use ::aws_smithy_types::config_bag::ConfigBag;

pub use ::aws_credential_types::Credentials;

pub use ::aws_types::region::Region;

impl From<&::aws_types::sdk_config::SdkConfig> for Builder {
    fn from(input: &::aws_types::sdk_config::SdkConfig) -> Self {
        let mut builder = Builder::default();
        builder.set_credentials_cache(input.credentials_cache().cloned());
        builder.set_credentials_provider(input.credentials_provider());
        builder = builder.region(input.region().cloned());
        builder.set_use_fips(input.use_fips());
        builder.set_use_dual_stack(input.use_dual_stack());
        builder.set_endpoint_url(input.endpoint_url().map(|s| s.to_string()));
        // resiliency
        builder.set_retry_config(input.retry_config().cloned());
        builder.set_timeout_config(input.timeout_config().cloned());
        builder.set_sleep_impl(input.sleep_impl());

        builder.set_http_connector(input.http_connector().cloned());
        builder.set_time_source(input.time_source());
        builder.set_app_name(input.app_name().cloned());

        builder
    }
}

impl From<&::aws_types::sdk_config::SdkConfig> for Config {
    fn from(sdk_config: &::aws_types::sdk_config::SdkConfig) -> Self {
        Builder::from(sdk_config).build()
    }
}

pub use ::aws_types::app_name::AppName;

pub use ::aws_smithy_async::rt::sleep::{AsyncSleep, SharedAsyncSleep, Sleep};

pub(crate) fn base_client_runtime_plugins(mut config: crate::Config) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
    let mut configured_plugins = ::std::vec::Vec::new();
    ::std::mem::swap(&mut config.runtime_plugins, &mut configured_plugins);
    let mut plugins = ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins::new()
        .with_client_plugin(
            ::aws_smithy_runtime_api::client::runtime_plugin::StaticRuntimePlugin::new()
                .with_config(config.config.clone())
                .with_runtime_components(config.runtime_components.clone()),
        )
        .with_client_plugin(crate::config::ServiceRuntimePlugin::new(config))
        .with_client_plugin(::aws_smithy_runtime::client::auth::no_auth::NoAuthRuntimePlugin::new());
    for plugin in configured_plugins {
        plugins = plugins.with_client_plugin(plugin);
    }
    plugins
}

fn set_connector(resolver: &mut ::aws_smithy_runtime::client::config_override::Resolver<'_>) {
    // Initial configuration needs to set a default if no connector is given, so it
    // should always get into the condition below.
    //
    // Override configuration should set the connector if the override config
    // contains a connector, sleep impl, or a timeout config since these are all
    // incorporated into the final connector.
    let must_set_connector = resolver.is_initial()
        || resolver.is_latest_set::<::aws_smithy_client::http_connector::HttpConnector>()
        || resolver.latest_sleep_impl().is_some()
        || resolver.is_latest_set::<::aws_smithy_types::timeout::TimeoutConfig>();
    if must_set_connector {
        let sleep_impl = resolver.sleep_impl();
        let timeout_config = resolver
            .resolve_config::<::aws_smithy_types::timeout::TimeoutConfig>()
            .cloned()
            .unwrap_or_else(::aws_smithy_types::timeout::TimeoutConfig::disabled);
        let connector_settings = ::aws_smithy_client::http_connector::ConnectorSettings::from_timeout_config(&timeout_config);
        let http_connector = resolver.resolve_config::<::aws_smithy_client::http_connector::HttpConnector>();

        // TODO(enableNewSmithyRuntimeCleanup): Replace the tower-based DynConnector and remove DynConnectorAdapter when deleting the middleware implementation
        let connector = http_connector
            .and_then(|c| c.connector(&connector_settings, sleep_impl.clone()))
            .or_else(|| crate::config::default_connector(&connector_settings, sleep_impl))
            .map(|c| {
                ::aws_smithy_runtime_api::client::connectors::SharedHttpConnector::new(
                    ::aws_smithy_runtime::client::connectors::adapter::DynConnectorAdapter::new(c),
                )
            });

        resolver.runtime_components_mut().set_http_connector(connector);
    }
}

fn set_endpoint_resolver(resolver: &mut ::aws_smithy_runtime::client::config_override::Resolver<'_>) {
    let endpoint_resolver = if resolver.is_initial() {
        Some(
            resolver
                .resolve_config::<::aws_smithy_http::endpoint::SharedEndpointResolver<crate::config::endpoint::Params>>()
                .cloned()
                .unwrap_or_else(|| ::aws_smithy_http::endpoint::SharedEndpointResolver::new(crate::config::endpoint::DefaultResolver::new())),
        )
    } else if resolver.is_latest_set::<::aws_smithy_http::endpoint::SharedEndpointResolver<crate::config::endpoint::Params>>() {
        resolver
            .resolve_config::<::aws_smithy_http::endpoint::SharedEndpointResolver<crate::config::endpoint::Params>>()
            .cloned()
    } else {
        None
    };
    if let Some(endpoint_resolver) = endpoint_resolver {
        let shared = ::aws_smithy_runtime_api::client::endpoint::SharedEndpointResolver::new(
            ::aws_smithy_runtime::client::orchestrator::endpoints::DefaultEndpointResolver::<crate::config::endpoint::Params>::new(endpoint_resolver),
        );
        resolver
            .runtime_components_mut()
            .set_endpoint_resolver(::std::option::Option::Some(shared));
    }
}

/// Types needed to configure endpoint resolution.
pub mod endpoint;

/// Types needed to implement [`Interceptor`](crate::config::Interceptor).
pub mod interceptors;

/// Retry configuration.
pub mod retry;

/// Timeout configuration.
pub mod timeout;

#[cfg(feature = "rustls")]
fn default_connector(
    connector_settings: &::aws_smithy_client::http_connector::ConnectorSettings,
    sleep_impl: ::std::option::Option<::aws_smithy_async::rt::sleep::SharedAsyncSleep>,
) -> ::std::option::Option<::aws_smithy_client::erase::DynConnector> {
    ::aws_smithy_client::conns::default_connector(connector_settings, sleep_impl)
}

#[cfg(not(feature = "rustls"))]
fn default_connector(
    _connector_settings: &::aws_smithy_client::http_connector::ConnectorSettings,
    _sleep_impl: ::std::option::Option<::aws_smithy_async::rt::sleep::SharedAsyncSleep>,
) -> ::std::option::Option<::aws_smithy_client::erase::DynConnector> {
    ::std::option::Option::None
}
